// ShitRust Text Adventure Game
// This program demonstrates object-oriented programming, state management, and game logic

// Import required modules
import { stdin, stdout } from "std/io";
import { Vector, HashMap } from "std/collections";
import { Random } from "std/math";

// Define Item struct
struct Item {
    name: string,
    description: string,
    can_be_taken: bool,
    
    // Constructor for creating a new item
    static fn new(name: string, description: string, can_be_taken: bool) -> Item {
        return Item {
            name: name,
            description: description,
            can_be_taken: can_be_taken
        };
    }
    
    // Display the item description
    fn examine() -> void {
        println(self.description);
    }
}

// Define Room struct
struct Room {
    id: string,
    name: string,
    description: string,
    exits: HashMap<string, string>,  // direction -> room_id
    items: Vector<Item>,
    
    // Constructor for creating a new room
    static fn new(id: string, name: string, description: string) -> Room {
        return Room {
            id: id,
            name: name,
            description: description,
            exits: HashMap<string, string>::new(),
            items: Vector<Item>::new()
        };
    }
    
    // Add an exit to the room
    fn add_exit(direction: string, room_id: string) -> void {
        self.exits.insert(direction, room_id);
    }
    
    // Add an item to the room
    fn add_item(item: Item) -> void {
        self.items.push(item);
    }
    
    // Remove an item from the room
    fn remove_item(item_name: string) -> result<Item, string> {
        for i in 0..self.items.length() {
            if self.items[i].name.to_lowercase() == item_name.to_lowercase() {
                let item = self.items[i];
                if !item.can_be_taken {
                    return err("You can't take the " + item_name + ".");
                }
                self.items.remove(i);
                return ok(item);
            }
        }
        return err("There is no " + item_name + " here.");
    }
    
    // Check if a room has an exit in a given direction
    fn has_exit(direction: string) -> bool {
        return self.exits.contains_key(direction);
    }
    
    // Get the ID of the room in a given direction
    fn get_exit(direction: string) -> string {
        return self.exits[direction];
    }
    
    // Display the room description and available exits
    fn describe() -> void {
        println(self.name);
        println(self.description);
        
        // List items in the room
        if self.items.length() > 0 {
            println("\nYou can see:");
            for item in self.items {
                println("- " + item.name);
            }
        }
        
        // List available exits
        println("\nExits:");
        let directions = self.exits.keys();
        for direction in directions {
            println("- " + direction);
        }
    }
}

// Define Player struct
struct Player {
    current_room_id: string,
    inventory: Vector<Item>,
    health: int,
    
    // Constructor for creating a new player
    static fn new(starting_room_id: string) -> Player {
        return Player {
            current_room_id: starting_room_id,
            inventory: Vector<Item>::new(),
            health: 100
        };
    }
    
    // Add an item to the player's inventory
    fn add_item(item: Item) -> void {
        self.inventory.push(item);
    }
    
    // Remove an item from the player's inventory
    fn remove_item(item_name: string) -> result<Item, string> {
        for i in 0..self.inventory.length() {
            if self.inventory[i].name.to_lowercase() == item_name.to_lowercase() {
                let item = self.inventory[i];
                self.inventory.remove(i);
                return ok(item);
            }
        }
        return err("You don't have a " + item_name + ".");
    }
    
    // Check if the player has a specific item
    fn has_item(item_name: string) -> bool {
        for item in self.inventory {
            if item.name.to_lowercase() == item_name.to_lowercase() {
                return true;
            }
        }
        return false;
    }
    
    // Display the player's inventory
    fn show_inventory() -> void {
        if self.inventory.length() == 0 {
            println("Your inventory is empty.");
            return;
        }
        
        println("Inventory:");
        for item in self.inventory {
            println("- " + item.name);
        }
    }
}

// Define Game struct
struct Game {
    rooms: HashMap<string, Room>,
    player: Player,
    running: bool,
    random: Random,
    
    // Constructor for creating a new game
    static fn new() -> Game {
        let game = Game {
            rooms: HashMap<string, Room>::new(),
            player: Player::new("entrance"),  // Start in the entrance
            running: true,
            random: Random::new()
        };
        
        // Initialize the game world
        game.setup_world();
        
        return game;
    }
    
    // Setup the game world with rooms and items
    fn setup_world() -> void {
        // Create rooms
        let entrance = Room::new("entrance", "Forest Entrance", 
            "You stand at the entrance to a dark, mysterious forest. " +
            "The trees loom overhead, their branches swaying in the gentle breeze.");
        entrance.add_exit("north", "clearing");
        entrance.add_exit("east", "path");
        entrance.add_item(Item::new("sign", "A wooden sign that reads: 'Beware of the forest creatures!'", false));
        
        let clearing = Room::new("clearing", "Forest Clearing", 
            "A small clearing in the forest. Sunlight filters through the canopy above. " +
            "There's a strange stone pedestal in the center.");
        clearing.add_exit("south", "entrance");
        clearing.add_exit("west", "cave");
        clearing.add_item(Item::new("flowers", "Beautiful wildflowers growing in patches.", true));
        clearing.add_item(Item::new("pedestal", "A stone pedestal with a slot that seems to fit something shiny.", false));
        
        let path = Room::new("path", "Winding Path", 
            "A narrow path winding through the trees. It's getting darker the further you go.");
        path.add_exit("west", "entrance");
        path.add_exit("north", "cabin");
        path.add_item(Item::new("mushrooms", "Some colorful mushrooms growing beside the path. They might be poisonous.", true));
        
        let cave = Room::new("cave", "Dark Cave", 
            "A dark, damp cave. Water drips from the ceiling, and you can barely see inside.");
        cave.add_exit("east", "clearing");
        cave.add_item(Item::new("torch", "An unlit torch mounted on the wall.", true));
        cave.add_item(Item::new("gems", "Sparkling gems embedded in the cave wall. Too hard to extract without tools.", false));
        
        let cabin = Room::new("cabin", "Abandoned Cabin", 
            "An old, abandoned cabin. The door creaks as you enter. " +
            "Dust covers every surface, and cobwebs hang from the ceiling.");
        cabin.add_exit("south", "path");
        cabin.add_item(Item::new("key", "A rusty key with strange markings.", true));
        cabin.add_item(Item::new("book", "An old, dusty book with arcane symbols on the cover.", true));
        
        // Add rooms to the game
        self.rooms.insert("entrance", entrance);
        self.rooms.insert("clearing", clearing);
        self.rooms.insert("path", path);
        self.rooms.insert("cave", cave);
        self.rooms.insert("cabin", cabin);
    }
    
    // Get the current room
    fn current_room() -> Room {
        return self.rooms[self.player.current_room_id];
    }
    
    // Process a player command
    fn process_command(command: string) -> void {
        let parts = command.to_lowercase().trim().split(" ");
        let action = parts[0];
        
        match action {
            "go" | "move" | "walk" => {
                if parts.length() < 2 {
                    println("Go where?");
                    return;
                }
                
                let direction = parts[1];
                self.move_player(direction);
            },
            "look" => {
                self.current_room().describe();
            },
            "examine" | "inspect" => {
                if parts.length() < 2 {
                    println("Examine what?");
                    return;
                }
                
                let item_name = parts[1];
                self.examine_item(item_name);
            },
            "take" | "get" => {
                if parts.length() < 2 {
                    println("Take what?");
                    return;
                }
                
                let item_name = parts[1];
                self.take_item(item_name);
            },
            "drop" => {
                if parts.length() < 2 {
                    println("Drop what?");
                    return;
                }
                
                let item_name = parts[1];
                self.drop_item(item_name);
            },
            "inventory" | "inv" | "i" => {
                self.player.show_inventory();
            },
            "use" => {
                if parts.length() < 2 {
                    println("Use what?");
                    return;
                }
                
                let item_name = parts[1];
                self.use_item(item_name);
            },
            "help" => {
                self.show_help();
            },
            "quit" | "exit" => {
                println("Are you sure you want to quit? (y/n)");
                let answer = stdin.read_line().trim().to_lowercase();
                if answer == "y" || answer == "yes" {
                    self.running = false;
                }
            },
            _ => {
                println("I don't understand that command. Type 'help' for a list of commands.");
            }
        }
    }
    
    // Move the player in a given direction
    fn move_player(direction: string) -> void {
        let current_room = self.current_room();
        
        if current_room.has_exit(direction) {
            let new_room_id = current_room.get_exit(direction);
            self.player.current_room_id = new_room_id;
            println("You go " + direction + ".");
            self.current_room().describe();
            
            // Random encounters (10% chance)
            if self.random.next_int(1, 10) == 1 {
                println("\nYou hear rustling in the bushes...");
                println("A forest creature appears!");
                println("It looks at you curiously, then scurries away.");
            }
        } else {
            println("You can't go that way.");
        }
    }
    
    // Examine an item
    fn examine_item(item_name: string) -> void {
        // Check if the item is in the room
        let current_room = self.current_room();
        
        for item in current_room.items {
            if item.name.to_lowercase() == item_name.to_lowercase() {
                item.examine();
                return;
            }
        }
        
        // Check if the item is in the player's inventory
        for item in self.player.inventory {
            if item.name.to_lowercase() == item_name.to_lowercase() {
                item.examine();
                return;
            }
        }
        
        println("You don't see a " + item_name + " here.");
    }
    
    // Take an item from the current room
    fn take_item(item_name: string) -> void {
        let result = self.rooms[self.player.current_room_id].remove_item(item_name);
        
        match result {
            ok(item) => {
                self.player.add_item(item);
                println("You take the " + item_name + ".");
            },
            err(message) => {
                println(message);
            }
        }
    }
    
    // Drop an item from the player's inventory
    fn drop_item(item_name: string) -> void {
        let result = self.player.remove_item(item_name);
        
        match result {
            ok(item) => {
                self.rooms[self.player.current_room_id].add_item(item);
                println("You drop the " + item_name + ".");
            },
            err(message) => {
                println(message);
            }
        }
    }
    
    // Use an item from the player's inventory
    fn use_item(item_name: string) -> void {
        if !self.player.has_item(item_name) {
            println("You don't have a " + item_name + ".");
            return;
        }
        
        // Special item interactions
        match item_name {
            "key" => {
                if self.player.current_room_id == "clearing" {
                    println("You insert the key into the pedestal.");
                    println("The ground begins to shake, and a secret passage opens!");
                    
                    // Add a new room and connection
                    if !self.rooms.contains_key("treasure") {
                        let treasure_room = Room::new("treasure", "Hidden Treasure Room", 
                            "A secret room filled with ancient treasures. Gold coins and jewels glitter in the dim light.");
                        treasure_room.add_exit("up", "clearing");
                        treasure_room.add_item(Item::new("crown", "A magnificent golden crown, encrusted with jewels.", true));
                        
                        self.rooms.insert("treasure", treasure_room);
                        self.rooms["clearing"].add_exit("down", "treasure");
                        
                        println("A passage leading down has appeared!");
                    } else {
                        println("The passage to the treasure room is already open.");
                    }
                } else {
                    println("There's nothing here to use the key on.");
                }
            },
            "book" => {
                println("You open the ancient book and begin to read.");
                println("It contains mysterious incantations and tales of hidden treasures in the forest.");
                println("One passage mentions a key that opens a secret chamber beneath a stone pedestal.");
            },
            "torch" => {
                if self.player.current_room_id == "cave" {
                    println("You light the torch, illuminating the cave.");
                    println("In the newfound light, you notice a small alcove you missed before.");
                    println("There's a small chest tucked away in the corner!");
                    
                    // Add a new item to the cave
                    if !self.room_has_item("cave", "chest") {
                        self.rooms["cave"].add_item(Item::new("chest", "A small wooden chest with iron bindings.", true));
                    }
                } else {
                    println("You light the torch. It provides a warm, flickering light.");
                }
            },
            "chest" => {
                println("You open the chest to find a beautiful amulet inside!");
                
                if !self.player.has_item("amulet") {
                    self.player.add_item(Item::new("amulet", "A beautiful silver amulet with a blue gemstone.", true));
                    println("You found an amulet and added it to your inventory!");
                }
            },
            "mushrooms" => {
                println("You eat the mushrooms. They taste... strange.");
                println("Your vision begins to blur, and you feel dizzy.");
                println("Maybe that wasn't a good idea...");
                
                self.player.health -= 20;
                println("Your health decreases to " + self.player.health.to_string() + ".");
                
                if self.player.health <= 0 {
                    println("\nYou collapse to the ground, overcome by the mushrooms' poison.");
                    println("GAME OVER");
                    self.running = false;
                }
            },
            "flowers" => {
                println("You smell the beautiful flowers. Their sweet fragrance makes you feel refreshed.");
                
                if self.player.health < 100 {
                    self.player.health += 10;
                    if self.player.health > 100 {
                        self.player.health = 100;
                    }
                    println("You feel better. Your health increases to " + self.player.health.to_string() + ".");
                }
            },
            "crown" => {
                println("You put on the crown and feel a sense of accomplishment.");
                println("Congratulations! You've found the treasure and completed the adventure!");
                println("\nTHE END");
                
                println("\nWould you like to continue exploring? (y/n)");
                let answer = stdin.read_line().trim().to_lowercase();
                if answer != "y" && answer != "yes" {
                    self.running = false;
                }
            },
            _ => {
                println("You're not sure how to use the " + item_name + ".");
            }
        }
    }
    
    // Check if a room has a specific item
    fn room_has_item(room_id: string, item_name: string) -> bool {
        if !self.rooms.contains_key(room_id) {
            return false;
        }
        
        let room = self.rooms[room_id];
        
        for item in room.items {
            if item.name.to_lowercase() == item_name.to_lowercase() {
                return true;
            }
        }
        
        return false;
    }
    
    // Show help information
    fn show_help() -> void {
        println("Available commands:");
        println("- go [direction] - Move in a direction (north, south, east, west)");
        println("- look - Look around the current location");
        println("- examine [item] - Examine an item more closely");
        println("- take [item] - Take an item from the room");
        println("- drop [item] - Drop an item from your inventory");
        println("- inventory (or 'inv', 'i') - Show your inventory");
        println("- use [item] - Use an item in your inventory");
        println("- help - Show this help message");
        println("- quit - Quit the game");
    }
    
    // Start the game
    fn start() -> void {
        println("=== The Enchanted Forest Adventure ===");
        println("Type 'help' for a list of commands.\n");
        
        // Show the initial room description
        self.current_room().describe();
        
        // Main game loop
        while self.running {
            print("\n> ");
            let command = stdin.read_line();
            self.process_command(command);
        }
        
        println("Thanks for playing!");
    }
}

// Main function
fn main() -> void {
    let game = Game::new();
    game.start();
} 